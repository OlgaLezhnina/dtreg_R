---
title: "Introduction to dtreg"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to dtreg}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(dtreg)
```
You can use dtreg for the following tasks:

* Interact with data type registries (DTRs): currently, the [ePIC](https://fc4e-t4-3.github.io/) and [ORKG](https://orkg.org/) DTRs.

* Write your data as an instance of an [R6 class](https://cran.r-project.org/package=R6) in accordance with a DTR schema.

* Convert the results into machine-readable JSON-LD format. 

## 1. Load a DTR schema {#section1}

To load a DTR schema, you need to know its identifier (see the [help page](https://orkg.org/help-center/article/47/reborn_articles)), such as the ePIC datatype DOI or the ORKG template URL. For example, to report Wilcoxon test, you need the group_comparison schema, which has the ePIC DOI "https://doi.org/21.T11969/b9335ce2c99ed87735a6". If a valid identifier is used, you get an R object containing information about the DTR schema:

```{r}
dt <- dtreg::load_datatype("https://doi.org/21.T11969/b9335ce2c99ed87735a6")
```

In addition to the schema you requested (in this case, the group_comparison), you get schemata that you might need for using it (see [Nested structure](#section2)).
You can look at the list of these schemata:

```{r}
names(dt)
```
## 2. Create an instance 

To write down your data in accordance with a DTR schema, dtreg uses [R6 classes](https://cran.r-project.org/package=R6). Therefore, you need to create an instance of a specific class.

### Fields 

For doing that, you first need to know which fields you can use for the selected schema: 

```{r}
dtreg::show_fields(dt$group_comparison())
```

For example, this schema has the field "label". If your instance included only a label, it would be:

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  eval = FALSE,
  comment = "#>"
)
```

```{r}
labelled_inst <- dt$group_comparison(label = "my_test_results")
```

However, the data you want to write are usually more complex than this.
The [help page](https://orkg.org/help-center/article/47/reborn_articles) specifies which fields to use and what input is required by a field (e.g., another schema or a specific type of data, such as numeric).

### String, numeric, and data frame

The most frequently used types of input are string, numeric, and data frame.
Strings are used for labels and comments, and URLs are also presented as strings:

```{r}
method_url <- dt$software_method(has_support_url = "https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/wilcox.test")
```

Numeric values are also frequently used:

```{r}
dimensions <- dt$matrix_size(number_of_rows = 100,
                             number_of_columns = 5)
```

Some fields, such as "source_table", require a data frame: 

```{r}
my_dataframe <- data.frame(W = 44.5, p = 2.2e-16)
output_dataframe <- dt$data_item(source_table = my_dataframe)
```

Please check which elements you include in your data frame and how you assign the columns. When in doubt, look at your column with:

```{r}
class(my_dataframe$W)
```

The result should be either a [basic R data type](https://www.w3schools.com/r/r_data_types.asp) or an [R factor](https://www.w3schools.com/r/r_factors.asp).

By default, dtreg assigns a data frame a generic label "Table". If you want to give your data frame a label, you can use a tuple. Please always include first the data frame and then the name as a string in the tuple: 

```{r}
library(sets)
my_tuple <- sets::tuple(my_dataframe, "the Wilcoxon test results")
output_tuple <- dt$data_item(source_table = my_tuple)
```

These are the most frequently used types of input that you write in a field. 

### More than one input in a field

Sometimes a few objects should be written in one field.
In this case, simply concatenate them:

```{r}
var_1 <- dt$component(label = "var_1")
var_2 <- dt$component(label = "var_2")
two_vars <- dt$group_comparison(targets = c(var_1, var_2))
```

### Nested structure {#section2}

In the example above you can see that a field of a schema might require another schema.
This nested structure is important for making the data machine readable.
The example above can be also written this way, and you can choose which is more convenient for you: 

```{r}
two_vars <- dt$group_comparison(targets = c(dt$component(label = "var_1"),
                                            dt$component(label = "var_2")))
```

Please be attentive when writing the results. In case you misspell a variable, omit a comma separating two fields, forget a closing bracket, or make another seemingly tiny mistake, you will get an error message (something like "object 'inputt' not found"). You can experiment with such typos and see which error messages you get.

None of the fields are mandatory: you will not get an error message if you leave any field, or all of them, empty. It makes sense, though, to create a useful JSON-LD file.

## 3. Convert the instance into JSON-LD format

This stage is simple. This line gives you a string in JSON-LD format:

```{r}
my_instance_json <- dtreg::to_jsonld(my_instance)
```

You can save the result as a machine-readable JSON file in your working directory: 

```{r}
write(my_instance_json, "my_instance_file.json")
```


## Example: reporting data analysis with dtreg  

In this vignette, we show reporting data analysis results with dtreg. Let us report the following analysis, which is simplified for the illustration purposes:

```{r}
attach(iris)
virg_vers <- iris[iris$Species == "virginica"|iris$Species == "versicolor",]
wilc <- stats::wilcox.test(virg_vers$Petal.Length ~ virg_vers$Species)
```

We need to load (see [Load a DTR schema](#section1) above) the data_analysis ePIC datatype for the overall report, the data_preprocessing for selecting rows, and the group_comparison for Wilcoxon test:

```{r}
dt_all <-
  dtreg::load_datatype("https://doi.org/21.T11969/feeb33ad3e4440682a4d")
dt_prepr <-
  dtreg::load_datatype("https://doi.org/21.T11969/37182ecfb4474942e255")
dt_wilc <-
  dtreg::load_datatype("https://doi.org/21.T11969/b9335ce2c99ed87735a6")
```

Let us write down the preprocessing instance. Here, the software method does not include a software library, as we were merely selecting rows; the input is the initial Iris dataset, and the output is the resulting dataset.  

```{r}
software <- dt_prepr$software(label = "R",
                              versioninfo = "4.3.1")
soft_method <- dt_prepr$software_method(label = "select rows",
                                        part_of = software,
                                        is_implemented_by = 'virg_vers <- iris[iris$Species == "virginica"|iris$Species == "versicolor",]')

dim_iris <- dt_prepr$matrix_size(number_of_rows = 150,
                                 number_of_columns = 5)

input_prepr <- dt_prepr$data_item(label = "Iris dataset",
                                  has_characteristic = dim_iris,
                                  source_url = "https://search.r-project.org/CRAN/refmans/MVTests/html/iris.html")

dim_virg_vers <- dt_prepr$matrix_size(number_of_rows = 100,
                                      number_of_columns = 5)

output_prepr <- dt_prepr$data_item(label = "virg_vers",
                                   has_characteristic = dim_virg_vers)
instance_prepr <-
  dt_prepr$data_preprocessing(
    label = "select rows virginica and versicolor",
    executes = soft_method,
    has_input = input_prepr,
    has_output = output_prepr
  )
```

Let us now create an instance for Wilcoxon test. Here, we indicate the software library that we used to conduct the test, and we need to specify the target (dependent) variable. The input is the dataset created in the previous step, and the output is the result of Wilcoxon test.     

```{r}
dt_wilc <-
  load_datatype("https://doi.org/21.T11969/b9335ce2c99ed87735a6")

software <- dt_wilc$software(label = "R",
                             versioninfo = "4.3.1")
soft_library <- dt_wilc$software_library(
  label = "stats::wilcoxon",
  part_of = software,
  versioninfo = "4.3.1",
  has_support_url = "https://search.r-project.org/R/refmans/stats/html/wilcox.test.html"
)
soft_method <-
  dt_wilc$software_method(label = "Wilcoxon rank sum test",
                          part_of = soft_library,
                          is_implemented_by = "stats::wilcox.test(virg_vers$Petal.Length ~ virg_vers$Species)")
dim_virg_vers <- dt_wilc$matrix_size(number_of_rows = 100,
                                     number_of_columns = 5)
input <- dt_wilc$data_item(label = "virginica and versicolor",
                           has_characteristic = dim_virg_vers)
petal_length <- dt_wilc$component(label = "petal length")
df_result <-
  data.frame(W = 44.5,
             p = 2.2e-16,
             stringsAsFactors = FALSE)
output <- dt_wilc$data_item(source_table = df_result)
instance_wilc <- dt_wilc$group_comparison(
  label = "Wilcoxon iris petal length, virginica vs versicolor",
  executes = soft_method,
  has_input = input,
  targets = petal_length,
  has_output = output
)
```

Now, we include both instances in the final data_analysis instance:

```{r}
instance_all <- dt_all$data_analysis(
  label = "my_data_analysis",
  is_implemented_by = "my_github_link",
  has_part = c(instance_prepr, instance_wilc))
```

Finally, we convert the data_analysis instance into JSON-LD format and save the file:  

```{r}
instance_all_json <- dtreg::to_jsonld(instance_all)
write(instance_all_json, "instance_all_file.json")
```
