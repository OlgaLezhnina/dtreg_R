---
title: "Introduction to dtreg"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to dtreg}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(dtreg)
```
You can use dtreg for the following tasks:

* Interact with data type registries (DTRs): currently, the ePIC and the ORKG DTRs.

* Write down the results of your data analysis in accordance with a DTR schema.

* Convert the results into a machine-readable JSON-LD file. 

## 1. Load a DTR schema 

To load a DTR schema, you need to know its identifier.
For the EPIC, it is the datatype DOI, such as "https://doi.org/21.T11969/ff5e3f857788d20dd1aa".
For the ORKG, it is the template URL, such as "https://incubating.orkg.org/template/R836000".
If a valid identifier is used, you get an R object containing information about the DTR schema.

```{r}
dt <- dtreg::load_datatype("https://doi.org/21.T11969/ff5e3f857788d20dd1aa")
```
In addition to the schema you requested, you get related schemata, which could be  useful for reporting your results.
You can look at the list of these schemata:

```{r}
names(dt)
```
## 2. Create an instance 

To write down the data analysis results, dtreg uses R6 classes. Therefore, you need to create an instance of a specific class.

### Fields 

For doing that, you first need to know which fields you can use: 

```{r}
dtreg::show_fields(dt$statistical_test_of_difference())
```

For example, there is the field "label". If your instance included only a label, it would be:

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  eval = FALSE,
  comment = "#>"
)
```

```{r}
labelled_inst <- dt$statistical_test_of_difference(label = "my_test_results")
```

However, the data you want to write are usually more complex than this.
If you want to write down the results of your data analysis, we recommend consulting the help page XXX. There you can see whether a field of the schema requires another schema or a specific type of data (e.g., numeric).

### String, numeric, and data frame

Most frequently used types are string, numeric, and data frame.
Strings are used for labels and comments, and URLs are also presented as strings:

```{r}
method_URL <- dt$software_method(
                 has_support_URL = "https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/wilcox.test")
```

Numeric values are also frequently used:

```{r}
sample_size <- dt$sample_size(has_specified_numeric_value = 148)
```

Some fields, such as "has_format", require a data frame: 

```{r}
my_dataframe <- data.frame(p = 0.026, t = 2.3, df = 48, stringsAsFactors = FALSE)
output_dataframe <- dt$inferential_test_output(has_format = my_dataframe)
```

By default, a data frame is assigned a generic name "Table". If you want to give your data frame a name, you can use a tuple. Please always include first the data frame and then the name as a string in the tuple. 

```{r}
my_tuple <- sets::tuple(my_dataframe, "the Wilcoxon results")
output_tuple <- dt$inferential_test_output(has_format = my_tuple)
```

These are most frequently used types of input that you write in a field. 

### More than one input in a field

Sometimes a few objects should be written in one field.
In this case simply concatenate them:

```{r}
var_1 <- dt$statistical_variable(label = "var_1")
var_2 <- dt$statistical_variable(label = "var_2")
two_vars <- dt$statistical_test_of_difference(evaluates = c(var_1, var_2))
```

### Nested structure

In the example above you can see that a field of a schema might require another schema.
This nested structure is important for making the data machine readable.
It can be also written this way, and you can choose which is more convenient for you: 

```{r}
two_vars <- 
  dt$statistical_test_of_difference(
    evaluates = c(
      dt$statistical_variable(label = "var_1"),
      dt$statistical_variable(label = "var_2")
    )
  )
```

None of the fields are mandatory: you will not get an error message if you leave any field, or all of them, empty. It makes sense, though, to create a useful JSON-LD file.

### Example: writing down the Wilcoxon test results 

Explanations above referred to the results of Wilcoxon test.
Now, we will write an instance including the relevant data in accordance with suggestions on the help page XXX.


```{r}
var_1 <- dt$statistical_variable(label = "var_1")
var_2 <- dt$statistical_variable(label = "var_2")
two_vars <- dt$statistical_test_of_difference(evaluates = c(var_1, var_2))
```


## 3. Convert the instance into a JSON-LD file

This stage is simple:

```{r}
my_json <- dtreg::to_jsonld(my_instance)
```
The resulting JSON-LD file is machine readable. It can be submitted etc. 
