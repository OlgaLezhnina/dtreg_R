---
title: "dtreg"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{dtreg}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(dtreg)
```
You can use dtreg for the following tasks:

* Interact with data type registries (DTRs): currently, the ePIC and the ORKG DTRs.

* Write down the results of your data analysis in accordance with a DTR schema.

* Convert the results into a machine-actionable JSON-LD file. 

## Load a DTR schema 

To load a DTR schema, you need to know it identifier.
For the EPIC, it is the datatype DOI, such as "https://doi.org/21.T11969/ff5e3f857788d20dd1aa".
For the ORKG, it is the template URL, such as "https://incubating.orkg.org/template/R836000".
If a valid identifier is used, you get an R object containing information about the DTR schema.

```{r}
dt <- dtreg::load_datatype("https://doi.org/21.T11969/ff5e3f857788d20dd1aa")
```
In addition to the schema you requested, you get related schemata, which could be  useful for reporting your results.
You can look at the list of these schemata:

```{r}
names(dt)
```
## Create an instance 

To write down the data analysis results, dtreg uses R6 classes. Therefore, you need to create an instance of a specific class.

### Fields 

For doing that, you first need to know which fields you can use: 

```{r}
dtreg::show_fields(dt$statistical_test_of_difference())
```

For example, there is the field "label". If your instance included only a label, it would be:

```{r}
labelled_inst <- dt$statistical_test_of_difference(label = "my_test_results")
```

However, the results of your data analysis are more complex than this.
Thus, it is recommendable to consult the help page XXX which explains whether a field requires a schema or a specific type of data (e.g., numeric).  

### String, numeric, and data frame

Most frequently used types are string, numeric, and data frame.
Strings are used for labels and comments, and URLs are also presented as strings:

```{r}
method_URL <- dt$software_method(
                 has_support_URL = "https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/wilcox.test")
```

Numeric values are also typical:

```{r}
sample_size <- dt$sample_size(has_specified_numeric_value = 148)
```

Some fields, such as "has_format", require a data frame: 

```{r}
my_dataframe <- data.frame(p = 0.026, t = 2.3, df = 48, stringsAsFactors = FALSE)
output_dataframe <- dt$inferential_test_output(has_format = my_dataframe)

```

You can use a tuple instead. A tuple helps you to give your data fame a name if you do not want it to be assigned a generic name "Table". When creating a tuple, please always include first the data frame and then the name as a string. 

```{r}
my_tuple <- sets::tuple(my_dataframe, "the Wilcoxon results")
output_tuple <- dt$inferential_test_output(has_format = my_dataframe)
```
### More than one input in a field

Sometimes a few objects should be written in one field.
In this case simply concatenate them:

```{r}
var_1 <- dt$statistical_variable()
var_2 <- dt$statistical_variable()
two_vars <- dt$statistical_test_of_difference(evaluates = c(var_1, var_2))
```

### Nested structure

On the help page for the "statistical_test_of_difference", you can see that the field "executes" requires the schema "software method", which in turn has the field "uses software" requiring the schema "software library": 


```{r}
nested_inst <- dt$statistical_test_of_difference(
                  executes = dt$software_method(
                    uses_software = dt$software_library(
                      part_of = dt$software(label = "R"))))
```

This nested structure is informed by machine-actionability of the data and might seem a bit complicated at first. We intend to make it simpler with dtreg, and later versions will suggest very simple wrappers which will write the results for you.

### Gather all info to write an instance 

For a more structured presentation, let us first write all field inputs and then gather them for the instance. 

## Convert the instance into a JSON-LD file

This stage is simple:


```{r}
my_json <- dtreg::to_jsonld(labelled_inst)
```
